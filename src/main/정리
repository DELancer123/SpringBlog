1. Get 요청 = URL에 데이터를 담아 보내는 형태
key = value의 형태, Body로 데이터를 담아 보내지 않음

2. post, put, Delete 요청 (데이터를 변경하는 요청)
데이터를 담아 보내야 할 것이 많음
form 태그의 method = 'post'로 보내는 형태로 많이 사용
다만, form 태그의 경우 get과 post만 가능하다(put과 Delete로 불가능)
따라서 put과 Delete의 경우 자바스크립트로 요청을 함

이 경우, 어떤 form과 자바 스크립트를 혼용 하게 되므로 통일을 하게 됨
자바 스크립트로 AJAX 요청 + 데이터는 JSON으로 통일

* form:form 태그 >> post, put, delete, get이 모두 가능한 태그

스프링 컨트롤러는 key=value의 형태로 데이터가 날아오면 자동으로 파싱하여 병수에 담아줌
또한 key=value 형태를 오브젝트의 형태로 파싱하여 담아 줄 수도 있음
다만, 이 경우 반드시 Setter가 존재하여야 함

Post 방식의 key=value를 x-www-form-urlencoded 형태로
username = ssar
password = 1234 라고 받았을 때
해당 키 값이(username, password) 오브젝트의 변수명과 반드시 일치해야 함

Key=Value가 아닌 형태로 데이터가 날아오면
@RequestBody 어노테이션을 붙여 json 데이터를 자바 오브젝트로 파싱하여야 한다

혹은 form태그로 json 데이터를 요청하여야 한다


* AJAX를 사용하는 2가지 이유
1.요청에 대한 응답을 html이 아닌 data(Json)을 받기 위하여 (앱이나 웹이나 하나의 서버로 사용 가능)
2.비동기 통신을 하기 위하여

* 서비스가 필요한 이유
1.트랜잭션 관리
2.서비스의 의미때문
=> Repository는 단일 CRUD를 가지는 것과 다르게 다중 CRUD를 가지기 때문에

*DB의 격리수준
-트랜잭션 : 일이 처리되기 위한 가장 작은 단위
오라클 : READ COMMIT을 사용
=> 만약 A라는 트랜잭션에서 업데이트를 하고 B에서 셀렉트를 한다면 커밋이 끝난 데이터만 보여짐
즉, COMMIT 종료된 데이터만 READ 되게 됨.
(트랜잭션은 데이터의 변화가 있는 경우에 발생)
이 경우, A와 B가 동시에 트랜잭션을 발생 시키는 경우 데이터의 정합성 문제가 발생 할 수 있음
=> 커밋 시점에 따라 데이터가 보였다 안보였다 하는 현상이 발생 가능 (PHANTOM READ)
>> 이것을 해결하기 위하여 repeatable read 방식을 사용하여야 함

MYSQL : InnoDB 스토리지 엔진 사용 > Repeatable read 이상 사용 (데이터 부정합 발생 X)

*스프링 기존 방식의 순서와 문제점
기존에는 Requst를 하면 영속성, 트랜잭션, JDBC를 모두 시작하고 닫았지만
업데이트가 되면서 해당 작업이 열리는 시점이 변경 됨

1. request를 보내면 영속성 컨텍스트 시작
--컨트롤 통과(컨트롤에서도 분기 처리를 하기 때문에 부하를 줄이기 위해 서비스 단에서 처리
--Service 단
2. JDBC 커넥션 시작
3. 트랜잭션 시작
4. JDBC 커넥션 종료
5. 트랜잭션 종료 - Commit - 변경 검지 (실제 Update 수행)
6. 영속성 컨텍스트 종료
=> LAZY 전략 사용시 1차캐시에는 연결된 포린 객체가 아닌 프록시 객체가 저장됨, 이경우 영속성 컨텍스트 종료시점을 Controller 이후로 가져가게 됨
이럴 경우 컨트롤러에서 프록시를 호출시 영속성 컨텍스트가 열려있으므로 프록시 객체가 호출되게 됨
>> 트랜잭션을 시작하지 않고 JDBC 커넥션을 시작하여 프록시 객체가 실제 데이터로 바뀌고 커넥션을 종료함
이 케이스의 경우 장점은 서비스에서 컨텍스트를 종료하는 것이 아니므로 필요시 프록시 객체를 이용하여 다시 데이터를 호출할 수 있음
다만, 트랜잭션은 종료된 상태이므로 데이터 변경은 불가능함 (Select만 가능)


*해쉬의 특징
시큐리티 : 로그인 요청을 하는 경우 시큐리티가 요청에서 username과 password를 가로채어 감 (로그인 요청의 파라미터를 가로챔)
이후 시큐리티가 로그인을 진행 후 진행 완료 시 시큐리티 전용으로 가지고 있는 시큐리티 세션으로 유저 정보를 등록
등록 후 DI를 통해 필요할때 마다 유저정보를 가지고 올 수 있음 (스프링이 IOC로 관리)

해쉬란 값을 고정길이의 문자열 값으로 변경하는 것
예를 들어, "안녕"이란 String 을 해쉬 암호로 바꾸면 ABC365FC(예시임) 으로 바뀜
다음에도 "안녕"이란 String을 해쉬 암호로 바꾸면 ABC36FC로 바뀜
다만, "안녕!"을 해쉬암호로 바꾸면 3671AF28(길이가 동일)로 바뀌게 됨

만일, 300page짜리 책을 해쉬암호로 바꾸어도 876F3A1B와 같이 고정길이의 해시로 바뀌게 됨
만약 해당 책의 250p 내용이 변경 된 후 다시 해쉬를 하게 되면 해쉬 값이 바뀌게 됨
즉, 해쉬를 이용하면 내용이 변경 되기 전까지는 해쉬값이 그대로 이지만 값이 변경되면 해쉬값이 바뀌게 되므로
해쉬값을 비교하여 값이 위/변조 되었는지 확인도 가능함
