1. Get 요청 = URL에 데이터를 담아 보내는 형태
key = value의 형태, Body로 데이터를 담아 보내지 않음

2. post, put, Delete 요청 (데이터를 변경하는 요청)
데이터를 담아 보내야 할 것이 많음
form 태그의 method = 'post'로 보내는 형태로 많이 사용
다만, form 태그의 경우 get과 post만 가능하다(put과 Delete로 불가능)
따라서 put과 Delete의 경우 자바스크립트로 요청을 함

이 경우, 어떤 form과 자바 스크립트를 혼용 하게 되므로 통일을 하게 됨
자바 스크립트로 AJAX 요청 + 데이터는 JSON으로 통일

* form:form 태그 >> post, put, delete, get이 모두 가능한 태그

스프링 컨트롤러는 key=value의 형태로 데이터가 날아오면 자동으로 파싱하여 병수에 담아줌
또한 key=value 형태를 오브젝트의 형태로 파싱하여 담아 줄 수도 있음
다만, 이 경우 반드시 Setter가 존재하여야 함

Post 방식의 key=value를 x-www-form-urlencoded 형태로
username = ssar
password = 1234 라고 받았을 때
해당 키 값이(username, password) 오브젝트의 변수명과 반드시 일치해야 함

Key=Value가 아닌 형태로 데이터가 날아오면
@RequestBody 어노테이션을 붙여 json 데이터를 자바 오브젝트로 파싱하여야 한다

혹은 form태그로 json 데이터를 요청하여야 한다


* AJAX를 사용하는 2가지 이유
1.요청에 대한 응답을 html이 아닌 data(Json)을 받기 위하여 (앱이나 웹이나 하나의 서버로 사용 가능)
2.비동기 통신을 하기 위하여

* 서비스가 필요한 이유
1.트랜잭션 관리
2.서비스의 의미때문
=> Repository는 단일 CRUD를 가지는 것과 다르게 다중 CRUD를 가지기 때문에

*DB의 격리수준
-트랜잭션 : 일이 처리되기 위한 가장 작은 단위
오라클 : READ COMMIT을 사용
=> 만약 A라는 트랜잭션에서 업데이트를 하고 B에서 셀렉트를 한다면 커밋이 끝난 데이터만 보여짐
즉, COMMIT 종료된 데이터만 READ 되게 됨.
(트랜잭션은 데이터의 변화가 있는 경우에 발생)
이 경우, A와 B가 동시에 트랜잭션을 발생 시키는 경우 데이터의 정합성 문제가 발생 할 수 있음
=> 커밋 시점에 따라 데이터가 보였다 안보였다 하는 현상이 발생 가능 (PHANTOM READ)
>> 이것을 해결하기 위하여 repeatable read 방식을 사용하여야 함

MYSQL : InnoDB 스토리지 엔진 사용 > Repeatable read 이상 사용 (데이터 부정합 발생 X)

*스프링 기존 방식의 순서와 문제점
기존에는 Requst를 하면 영속성, 트랜잭션, JDBC를 모두 시작하고 닫았지만
업데이트가 되면서 해당 작업이 열리는 시점이 변경 됨

1. request를 보내면 영속성 컨텍스트 시작
--컨트롤 통과(컨트롤에서도 분기 처리를 하기 때문에 부하를 줄이기 위해 서비스 단에서 처리
--Service 단
2. JDBC 커넥션 시작
3. 트랜잭션 시작
4. JDBC 커넥션 종료
5. 트랜잭션 종료 - Commit - 변경 검지 (실제 Update 수행)
6. 영속성 컨텍스트 종료
=> LAZY 전략 사용시 1차캐시에는 연결된 포린 객체가 아닌 프록시 객체가 저장됨, 이경우 영속성 컨텍스트 종료시점을 Controller 이후로 가져가게 됨
이럴 경우 컨트롤러에서 프록시를 호출시 영속성 컨텍스트가 열려있으므로 프록시 객체가 호출되게 됨
>> 트랜잭션을 시작하지 않고 JDBC 커넥션을 시작하여 프록시 객체가 실제 데이터로 바뀌고 커넥션을 종료함
이 케이스의 경우 장점은 서비스에서 컨텍스트를 종료하는 것이 아니므로 필요시 프록시 객체를 이용하여 다시 데이터를 호출할 수 있음
다만, 트랜잭션은 종료된 상태이므로 데이터 변경은 불가능함 (Select만 가능)
